package io.github.darhkdevelopments.antichestcrash;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

import org.bukkit.Material;
import org.bukkit.entity.Item;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerDropItemEvent;
import org.bukkit.inventory.ItemStack;


public class ExploitListeners implements Listener 
{
	
	@EventHandler(ignoreCancelled = true)
	public void onPlayerItemDrop(PlayerDropItemEvent ev) 
	{
		
		Item i = ev.getItemDrop();
		ItemStack is = i.getItemStack();
		
		/* Only look at chests, trapped chests, and ender chests */
		if(is.getType() == Material.CHEST || is.getType() ==  Material.TRAPPED_CHEST || is.getType() == Material.ENDER_CHEST)
		{
			Player p = ev.getPlayer();
			AntiChestCrash instance = AntiChestCrash.getInstance();
			Logger logger = instance.getLogger();
			Object cis = null;
		
			/* Get the ItemStack as NMS */
			
			try {
				cis = getItemStack(is);
			} 
			
			catch(Exception e) {
				cis = null;
			}
			
			
			if(cis != null)
			{
				/* Get the tags in the NBTData */
				Object tags = getTags(cis);
				
				if(tags != null)
				{
					/* Look at the key set */
					Set keySet = getKeySet(tags);
					
					if(keySet != null)
					{
						/* Should not be normally possible to have more than 15 keys, if detected, could be a version of the chest crasher exploit */
						if(keySet.size() > 15) 
						{
							blockChestExploit(p, ev); // Block the exploit
						}
						
						/* Get the method which retrieves the value from the map based upon the key */
						Method getMethod = getGetMethod(tags);
						if(getMethod != null)
						{
							
							/* Validate our nbt data */
							boolean valid = validateData(keySet, getMethod, tags);
							
							/* Detected corrupted data */
							if(!valid)
							{
								blockChestExploit(p,ev); // Block the exploit
							}
						}
						
					}
				}
				
			}
			
			
		}
	
	}
	
	
	/* Blocks the exploit */
	public void blockChestExploit(Player p, PlayerDropItemEvent ev)
	{
		ev.setCancelled(true); // Cancel the drop event, so no one can pick it up
		p.kickPlayer("Chest Exploit Detected"); // Kick player with a message
		p.setBanned(true); // Probably should ban the user.
	}

	
	/* Method which retrieves the tags from the nbt data */
	public Object getTags(Object cis)
	{

		for(Method m : cis.getClass().getMethods())
		{
			if(m.getName().equals("getTag"))
			{
				try 
				{
					Object tags = m.invoke(cis, null);
					return tags;
				}
				
				catch(Exception ex)
				{
					return null;
				}
			}
		}
		
		return null;						
	}
	
	/* Will validate the nbt data to make sure it is not corrupted */
	public boolean validateData(Set keySet, Method get, Object tags)
	{
		for(Object o : keySet)
		{
			try
			{
				Object res = get.invoke(tags, o);
				
				if(res != null)
				{
					String resType = res.getClass().getName();
					
					
					if(resType.contains("NBTTagCompound"))
					{
						// Go one level deeper
						Set ks2 = this.getKeySet(res);
					
						for(Object o2 : ks2)
						{
							Object res2 = get.invoke(res, o2);
							String res2Type = res2.getClass().getName();
							
							// Nesting detected
							if(res2Type.contains("NBTTagCompound") || res2Type.contains("NBTTagList"))
							{
								return false;
							}
						}
					}
					
					// Dropped chests should not contain this key at top level
					else if(resType.contains("NBTTagList"))
					{
						return false;
					}
					
				}
					
			}
			
			catch(Exception e)
			{
				e.printStackTrace();
			}
			
		}
		
		return true;
	}
	
	/* Gets the "get" method, which allows us to poll a value from the map based upon the key */
	public Method getGetMethod(Object tags)
	{
		for(Method me : tags.getClass().getMethods())
		{
			if(me.getName().equals("get"))
			{
				return me;
			}
		}
		
		return null;						
	}
	
	/* Gets the key set from the map */
	public Set getKeySet(Object tags)
	{

		for(Method me : tags.getClass().getMethods())
		{
			if(me.getName().equals("c"))
			{
				try
				{
					Set keySet = (Set) me.invoke(tags, null);
					return keySet;
				}
				catch(Exception ex)
				{
					return null;
				}
			}
		}
		
		return null;						
	}
	
	/* Gets the ItemStack as a NMS Copy */
	public Object getItemStack(ItemStack i) throws ClassNotFoundException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException 
	{
        	Class<?> craftItemStack = Class.forName(AntiChestCrash.getInstance().getServer().getClass().getPackage().getName() + ".inventory.CraftItemStack");
        
        	for (Method m : craftItemStack.getMethods()) 
        	{
            		if (m.getName().equals("asNMSCopy") && m.getParameterTypes().length == 1) 
            		{
                		return m.invoke(this, i); 
            		}
        	}
        	
        	return null;
    	}
	


}
